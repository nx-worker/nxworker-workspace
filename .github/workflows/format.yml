name: Format Code

on:
  workflow_dispatch:

permissions:
  contents: write # needed to amend commits and force push
  actions: write # needed to modify files in .github/workflows/

jobs:
  format:
    runs-on: ubuntu-24.04-arm
    steps:
      - uses: actions/checkout@v5
        with:
          # Fetch all history to compare with main branch
          fetch-depth: 0
          # Use token that allows force push
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Check if running on default branch
        id: check-branch
        run: |
          # Determine the default branch dynamically
          DEFAULT_BRANCH=$(gh repo view --json defaultBranchRef --jq '.defaultBranchRef.name')
          echo "default-branch=$DEFAULT_BRANCH" >> $GITHUB_OUTPUT

          # Prevent running on the default branch
          if [ "$GITHUB_REF" == "refs/heads/$DEFAULT_BRANCH" ]; then
            echo "Error: This workflow cannot run on the default branch ($DEFAULT_BRANCH)"
            exit 1
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - uses: ./.github/actions/set-nx-shas

      - uses: ./.github/actions/setup-node-and-install

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Format commits
        shell: bash -e {0}
        run: |
          # Get the default branch from the previous step
          DEFAULT_BRANCH="${{ steps.check-branch.outputs.default-branch }}"

          # Get the current branch name
          CURRENT_BRANCH="${GITHUB_REF#refs/heads/}"

          # Check if this branch has an open pull request and use its target branch
          BASE_BRANCH=$(gh pr view "$CURRENT_BRANCH" --json baseRefName --jq '.baseRefName' 2>/dev/null || echo "")

          if [ -z "$BASE_BRANCH" ]; then
            # No PR found, use default branch
            BASE_BRANCH="$DEFAULT_BRANCH"
            echo "No open pull request found. Using default branch: $BASE_BRANCH"
          else
            echo "Found open pull request targeting: $BASE_BRANCH"
          fi

          echo "Formatting commits on branch: $CURRENT_BRANCH"
          echo "Comparing with base branch: $BASE_BRANCH"

          # Fetch the base branch
          git fetch origin "$BASE_BRANCH:$BASE_BRANCH"

          # Get the list of commits between base branch and current branch
          COMMITS=$(git rev-list --reverse "$BASE_BRANCH..$CURRENT_BRANCH")

          if [ -z "$COMMITS" ]; then
            echo "No commits to format (branch is up to date with $BASE_BRANCH)"
            exit 0
          fi

          echo "Found commits to format:"
          git log --oneline "$BASE_BRANCH..$CURRENT_BRANCH"
          echo ""

          # Get the merge base (common ancestor)
          MERGE_BASE=$(git merge-base "$BASE_BRANCH" "$CURRENT_BRANCH")
          echo "Merge base: $MERGE_BASE"

          # Check if the branch has been rebased with the latest base branch
          BASE_BRANCH_HEAD=$(git rev-parse "$BASE_BRANCH")
          echo "Base branch HEAD: $BASE_BRANCH_HEAD"

          if [ "$MERGE_BASE" != "$BASE_BRANCH_HEAD" ]; then
            echo ""
            echo "============================================"
            echo "ERROR: Branch has not been rebased"
            echo "============================================"
            echo ""
            echo "This branch has diverged from $BASE_BRANCH."
            echo "The merge base ($MERGE_BASE) does not match the HEAD of $BASE_BRANCH ($BASE_BRANCH_HEAD)."
            echo ""
            echo "This prevents the format workflow from running with an outdated version of its own workflow file."
            echo ""
            echo "To fix this issue, please rebase your branch:"
            echo "  git fetch origin $BASE_BRANCH"
            echo "  git rebase origin/$BASE_BRANCH"
            echo "  git push --force-with-lease"
            echo ""
            exit 1
          fi

          echo "✓ Branch is up to date with $BASE_BRANCH (rebase check passed)"
          echo ""

          # Reset to merge base to start replaying commits
          git reset --hard "$MERGE_BASE"

          # Process each commit
          for COMMIT in $COMMITS; do
            echo ""
            echo "=========================================="
            echo "Processing commit: $COMMIT"
            git log -1 --oneline "$COMMIT"
            echo "=========================================="
            
            # Check if this commit is empty (has no changes compared to its parent)
            if git diff-tree --no-commit-id --name-only -r "$COMMIT" | grep -q .; then
              # Commit has changes, process it normally
              
              # Track whether we should format this commit
              SHOULD_FORMAT=true
              
              # Cherry-pick the commit (this applies it to current HEAD)
              if ! git cherry-pick "$COMMIT"; then
                # Check if the cherry-pick resulted in an empty commit (changes already applied)
                # This can happen when a previous commit was formatted and the changes in the current
                # commit have already been applied. For example:
                # - Commit A: adds unformatted code
                # - Commit B: formats the same code
                # When we format Commit A, Commit B becomes empty and should be skipped.
                # Use --porcelain for reliable machine-readable status
                if [ -z "$(git status --porcelain)" ]; then
                  echo "⊘ Cherry-pick resulted in empty commit (changes already applied by earlier formatting fixes)"
                  echo "Skipping this commit..."
                  git cherry-pick --skip
                  SHOULD_FORMAT=false
                else
                  echo "⚠ Cherry-pick failed, likely due to formatting conflicts from earlier commits"
                  echo "Resolving conflicts by accepting incoming changes..."
                  
                  # Get the list of conflicted files
                  CONFLICTED_FILES=$(git diff --name-only --diff-filter=U)
                  
                  if [ -z "$CONFLICTED_FILES" ]; then
                    echo "Error: Cherry-pick failed but no conflicted files found"
                    git cherry-pick --abort
                    exit 1
                  fi
                  
                  echo "Conflicted files:"
                  echo "$CONFLICTED_FILES"
                  
                  # For each conflicted file, accept the incoming version (from the commit being cherry-picked)
                  for FILE in $CONFLICTED_FILES; do
                    echo "  Resolving: $FILE"
                    # Accept theirs (the version from the commit we're cherry-picking)
                    git checkout --theirs "$FILE"
                    git add "$FILE"
                  done
                  
                  # Complete the cherry-pick with resolved conflicts
                  git -c core.editor=true cherry-pick --continue
                  
                  echo "✓ Conflicts resolved, cherry-pick completed"
                fi
              fi
              
              # Run format check only if we have a commit to format
              if [ "$SHOULD_FORMAT" = true ]; then
                echo "Checking formatting..."
                if npx nx format:check; then
                  echo "✓ Commit is properly formatted, no changes needed"
                else
                  echo "✗ Formatting issues found, applying fixes..."
                  
                  # Apply formatting
                  npx nx format:write
                  
                  # Check if there are any changes after formatting
                  if ! git diff --quiet; then
                    echo "Amending commit with formatting changes..."
                    git add -A
                    git commit --amend --no-edit
                    echo "✓ Commit amended with formatting fixes"
                  else
                    echo "✓ No formatting changes needed after all"
                  fi
                fi
              fi
            else
              # Commit is empty, skip it
              echo "⊘ Skipping empty commit (no file changes)"
            fi
          done

          echo ""
          echo "=========================================="
          echo "All commits processed successfully"
          echo "=========================================="
          echo ""
          echo "Final commit history:"
          git log --oneline "$BASE_BRANCH..$CURRENT_BRANCH"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Force push formatted commits
        run: |
          # Force push the reformatted branch
          # Use --force-with-lease for safety (protects against concurrent updates)
          # Note: --force-if-includes requires Git 2.30+, so we use just --force-with-lease
          git push --force-with-lease origin "HEAD:${{ github.ref_name }}"
          echo "✓ Successfully pushed formatted commits to ${{ github.ref_name }}"
